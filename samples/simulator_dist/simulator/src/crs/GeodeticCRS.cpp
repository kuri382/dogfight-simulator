// Copyright (c) 2024-2025 Air Systems Research Center, Acquisition, Technology & Logistics Agency(ATLA)
#include "crs/GeodeticCRS.h"
#include "Units.h"
#include <algorithm>
#include <iomanip>
#include <limits>
#include <sstream>
#include <string>
#include <iomanip>

ASRC_NAMESPACE_BEGIN(asrc)
ASRC_NAMESPACE_BEGIN(core)

using namespace util;

GeodeticCRS::GeodeticCRS(const nl::json& modelConfig_,const nl::json& instanceConfig_)
:CoordinateReferenceSystem(modelConfig_,instanceConfig_){
    crsType=CRSType::ECEF;
}
// 内部状態のシリアライゼーション
void GeodeticCRS::serializeInternalState(asrc::core::util::AvailableArchiveTypes & archive, bool full){
    BaseType::serializeInternalState(archive,full);

    ASRC_SERIALIZE_NVP(archive
        ,_geog
        ,_ecef
        ,_spherical_ecef
        ,_eci
        ,_autoGenerated
        ,_isSpherical
        ,_semiMajorAxis
        ,_inverseFlattening
    )
}
void GeodeticCRS::validateImpl(bool isFirstTime) const{
    this->CoordinateReferenceSystem::validateImpl(isFirstTime);
    //他のGeodeticCRSと対になるものとして生成される場合はそのdatumの情報を優先して用いる。
    _autoGenerated=false;
    if(isGeographic()){
        //GeographicはCartesian ECEFから生成され得る。
        nl::json j;
        if(instanceConfig.contains("ecef")){
            j=instanceConfig.at("ecef");
            _autoGenerated=true;
        }else if(modelConfig.contains("ecef")){
            j=modelConfig.at("ecef");
            _autoGenerated=true;
        }
        if(_autoGenerated){
            assert(j.is_object());
            j["baseName"]="CoordinateReferenceSystem";
            _ecef=createOrGetEntity<GeodeticCRS>(j);
            if(_ecef){
                setGeographicCRS(_ecef,non_const_this<GeographicCRS>());
                _semiMajorAxis=_ecef->semiMajorAxis();
                _inverseFlattening=_ecef->inverseFlattening();
            }else{
                throw std::runtime_error("The given json does not represent a valid ECEF. j="+j.dump());
            }
            return;
        }
    }else if(isEarthFixed()){
        // 直交座標or極座標
        if(instanceConfig.contains("isSpherical")){
            _isSpherical=instanceConfig.at("isSpherical");
        }else if(modelConfig.contains("isSpherical")){
            _isSpherical=modelConfig.at("isSpherical");
        }else{
            _isSpherical=false;
        }
        if(!_isSpherical){
            //Cartesian ECEFはGeographicから生成され得る。
            nl::json j;
            if(instanceConfig.contains("geog")){
                j=instanceConfig.at("geog");
                _autoGenerated=true;
            }else if(modelConfig.contains("geog")){
                j=modelConfig.at("geog");
                _autoGenerated=true;
            }
            if(_autoGenerated){
                assert(j.is_object());
                j["baseName"]="CoordinateReferenceSystem";
                auto shared=createOrGetEntity<GeographicCRS>(j);
                if(shared){
                    setECEF(shared,non_const_this<GeodeticCRS>());
                    _semiMajorAxis=shared->semiMajorAxis();
                    _inverseFlattening=shared->inverseFlattening();
                    _geog=shared;
                }else{
                    throw std::runtime_error("The given json does not represent a valid geographic CRS. j="+j.dump());
                }
                return;
            }

            //Cartesian ECEFはSpherical ECEFからも生成され得る。
            if(instanceConfig.contains("spherical_ecef")){
                j=instanceConfig.at("spherical_ecef");
                _autoGenerated=true;
            }else if(modelConfig.contains("spherical_ecef")){
                j=modelConfig.at("spherical_ecef");
                _autoGenerated=true;
            }
            if(_autoGenerated){
                assert(j.is_object());
                j["baseName"]="CoordinateReferenceSystem";
                auto shared=createOrGetEntity<GeodeticCRS>(j);
                if(shared){
                    setECEF(shared,non_const_this<GeodeticCRS>());
                    _semiMajorAxis=shared->semiMajorAxis();
                    _inverseFlattening=shared->inverseFlattening();
                    _spherical_ecef=shared;
                }else{
                    throw std::runtime_error("The given json does not represent a valid geographic CRS. j="+j.dump());
                }
                return;
            }
        }else{
            //Spherical ECEFはCartesian ECEFから生成され得る。
            nl::json j;
            if(instanceConfig.contains("ecef")){
                j=instanceConfig.at("ecef");
                _autoGenerated=true;
            }else if(modelConfig.contains("ecef")){
                j=modelConfig.at("ecef");
                _autoGenerated=true;
            }
            if(_autoGenerated){
                assert(j.is_object());
                j["baseName"]="CoordinateReferenceSystem";
                _ecef=createOrGetEntity<GeodeticCRS>(j);
                if(_ecef){
                    setSphericalECEF(_ecef,non_const_this<GeodeticCRS>());
                    _semiMajorAxis=_ecef->semiMajorAxis();
                    _inverseFlattening=_ecef->inverseFlattening();
                }else{
                    throw std::runtime_error("The given json does not represent a valid ECEF. j="+j.dump());
                }
                return;
            }
        }
    }else{
        //ECIは対になるCartesian ECEFを必ず指定して生成しなければならない。
        _autoGenerated=true;
        nl::json j;
        if(instanceConfig.contains("ecef")){
            j=instanceConfig.at("ecef");
            _autoGenerated=true;
        }else if(modelConfig.contains("ecef")){
            j=modelConfig.at("ecef");
            _autoGenerated=true;
        }else{
            throw std::runtime_error("ECI requires the ECEF information in config, but not found.");
        }
        assert(j.is_object());
        j["baseName"]="CoordinateReferenceSystem";
        _ecef=createOrGetEntity<GeodeticCRS>(j);
        if(_ecef){
            setECI(_ecef,non_const_this<EarthCenteredInetialCRS>());
            _semiMajorAxis=_ecef->semiMajorAxis();
            _inverseFlattening=_ecef->inverseFlattening();
        }else{
            throw std::runtime_error("The given json does not represent a valid ECEF. j="+j.dump());
        }
        return;
    }
    if(!_autoGenerated){
        // 楕円体形状の指定
        if(instanceConfig.contains("semiMajorAxis")){
            _semiMajorAxis=instanceConfig.at("semiMajorAxis");
        }else if(modelConfig.contains("semiMajorAxis")){
            _semiMajorAxis=modelConfig.at("semiMajorAxis");
        }else{
            _semiMajorAxis=6378138.0; // 省略時はGRS80
        }
        if(instanceConfig.contains("inverseFlattening")){
            _inverseFlattening=instanceConfig.at("inverseFlattening");
        }else if(modelConfig.contains("inverseFlattening")){
            _inverseFlattening=modelConfig.at("inverseFlattening");
        }else{
            _inverseFlattening=298.257222101; // 省略時はGRS80
        }
        // 直交座標or極座標
        if(instanceConfig.contains("isSpherical")){
            _isSpherical=instanceConfig.at("isSpherical");
        }else if(modelConfig.contains("isSpherical")){
            _isSpherical=modelConfig.at("isSpherical");
        }else{
            _isSpherical=false;
        }
    }
}
//座標系の種類
bool GeodeticCRS::isEarthFixed() const{
    return true;
}
bool GeodeticCRS::isGeocentric() const{
    return true;
}
//中間座標系の取得
std::shared_ptr<CoordinateReferenceSystem> GeodeticCRS::getIntermediateCRS() const{
    return getECEF();
}
//Coordinate system axisの種類
bool GeodeticCRS::isCartesian() const{
    if(!isValid()){validate();}
    return !_isSpherical;
}
bool GeodeticCRS::isSpherical() const{
    if(!isValid()){validate();}
    return _isSpherical;
}
bool GeodeticCRS::isEllipsoidal() const{
    return false;
}

//「高度」の取得
double GeodeticCRS::getHeight(const Eigen::Vector3d& location, const Time& time) const{
    //楕円体高度(幾何高度)を返す。ellipsoid (geometric) height
    //ECEFの場合はGeographicに変換してそちらから返す。
    if(!isValid()){validate();}
    return getGeographicCRS()->getHeight(transformECEFCoordinateToGeographicCRS(toCartesian(location),CoordinateType::POSITION_ABS),time);
}
double GeodeticCRS::getGeoidHeight(const Eigen::Vector3d& location, const Time& time) const{
    //標高(ジオイド高度)を返す。geoid height (elevation)
    //ECEFの場合はGeographicに変換してそちらから返す。
    if(!isValid()){validate();}
    return getGeographicCRS()->getGeoidHeight(transformECEFCoordinateToGeographicCRS(toCartesian(location),CoordinateType::POSITION_ABS),time);
}

// CRSインスタンス間の変換可否
bool GeodeticCRS::isTransformableTo(const std::shared_ptr<CoordinateReferenceSystem>& other) const{
    if(!other){
        return false;
    }
    if(auto derived=std::dynamic_pointer_cast<DerivedCRS>(other)){
        return isTransformableTo(derived->getNonDerivedBaseCRS());
    }else if(auto geodetic=std::dynamic_pointer_cast<GeodeticCRS>(other)){
        return isTransformableToAnotherGeodeticCRS(geodetic);
    }else{
        return false;
    }
}
bool GeodeticCRS::isTransformableFrom(const std::shared_ptr<CoordinateReferenceSystem>& other) const{
    if(!other){
        return false;
    }
    if(auto derived=std::dynamic_pointer_cast<DerivedCRS>(other)){
        return isTransformableFrom(derived->getNonDerivedBaseCRS());
    }else if(auto geodetic=std::dynamic_pointer_cast<GeodeticCRS>(other)){
        return isTransformableFromAnotherGeodeticCRS(geodetic);
    }else{
        return false;
    }
}

// 座標変換
Coordinate GeodeticCRS::transformTo(const Eigen::Vector3d& value, const Eigen::Vector3d& location, const Time& time, const std::shared_ptr<CoordinateReferenceSystem>& dstCRS, const CoordinateType& coordinateType) const{
    if(!isValid()){validate();}
    if(!dstCRS){
        throw std::runtime_error("dstCRS is nullptr!");
    }
    if(this==std::dynamic_pointer_cast<GeodeticCRS>(dstCRS).get()){
        return std::move(Coordinate(
            value,
            location,
            dstCRS,
            time,
            coordinateType
        ));
    }
    if(!isTransformableTo(dstCRS)){
        throw std::runtime_error(getFactoryClassName()+" can't be transformed to "+dstCRS->getFactoryClassName());
    }
    if(auto derived=std::dynamic_pointer_cast<DerivedCRS>(dstCRS)){
        auto intermediate=derived->getIntermediateCRS();
        auto valueInIntermediate=transformTo(value,location,time,intermediate,coordinateType);
        return derived->transformFromIntermediateCRS(
            valueInIntermediate(),
            valueInIntermediate.getLocation(),
            time,
            coordinateType
        );
    }else{
        auto geodetic=std::dynamic_pointer_cast<GeodeticCRS>(dstCRS);
        assert(geodetic);
        return transformToAnotherGeodeticCRS(value,location,time,geodetic,coordinateType);
    }
}
Coordinate GeodeticCRS::transformFrom(const Eigen::Vector3d& value, const Eigen::Vector3d& location, const Time& time, const std::shared_ptr<CoordinateReferenceSystem>& srcCRS, const CoordinateType& coordinateType) const{
    if(!isValid()){validate();}
    if(!srcCRS){
        throw std::runtime_error("srcCRS is nullptr!");
    }
    if(this==std::dynamic_pointer_cast<GeodeticCRS>(srcCRS).get()){
        return std::move(Coordinate(
            value,
            location,
            srcCRS,
            time,
            coordinateType
        ));
    }
    if(!isTransformableFrom(srcCRS)){
        throw std::runtime_error(getFactoryClassName()+" can't be transformed from "+srcCRS->getFactoryClassName());
    }
    if(auto derived=std::dynamic_pointer_cast<DerivedCRS>(srcCRS)){
        auto intermediate=derived->getIntermediateCRS();
        auto valueInIntermediate=derived->transformToIntermediateCRS(value,location,time,coordinateType);
        return transformFrom(
            valueInIntermediate(),
            valueInIntermediate.getLocation(),
            time,
            intermediate,
            coordinateType
        );
    }else{
        auto geodetic=std::dynamic_pointer_cast<GeodeticCRS>(srcCRS);
        assert(geodetic);
        return transformFromAnotherGeodeticCRS(value,location,time,geodetic,coordinateType);
    }
}
Quaternion GeodeticCRS::getQuaternionTo(const Eigen::Vector3d& location, const Time& time, const std::shared_ptr<CoordinateReferenceSystem>& dstCRS) const{
    if(!isValid()){validate();}
    if(!dstCRS){
        throw std::runtime_error("dstCRS is nullptr!");
    }
    if(this==std::dynamic_pointer_cast<GeodeticCRS>(dstCRS).get()){
        return Quaternion(1,0,0,0);
    }
    if(!isTransformableTo(dstCRS)){
        throw std::runtime_error(getFactoryClassName()+" can't be transformed to "+dstCRS->getFactoryClassName());
    }
    if(auto derived=std::dynamic_pointer_cast<DerivedCRS>(dstCRS)){
        return derived->getQuaternionFrom(location,time,non_const_this());
    }else{
        auto geodetic=std::dynamic_pointer_cast<GeodeticCRS>(dstCRS);
        assert(geodetic);
        return getQuaternionToAnotherGeodeticCRS(location,time,geodetic);
    }
}
Quaternion GeodeticCRS::getQuaternionFrom(const Eigen::Vector3d& location, const Time& time, const std::shared_ptr<CoordinateReferenceSystem>& srcCRS) const{
    if(!isValid()){validate();}
    if(!srcCRS){
        throw std::runtime_error("srcCRS is nullptr!");
    }
    if(this==std::dynamic_pointer_cast<GeodeticCRS>(srcCRS).get()){
        return Quaternion(1,0,0,0);
    }
    if(!isTransformableFrom(srcCRS)){
        throw std::runtime_error(getFactoryClassName()+" can't be transformed from "+srcCRS->getFactoryClassName());
    }
    if(auto derived=std::dynamic_pointer_cast<DerivedCRS>(srcCRS)){
        return derived->getQuaternionTo(location,time,non_const_this());
    }else{
        auto geodetic=std::dynamic_pointer_cast<GeodeticCRS>(srcCRS);
        assert(geodetic);
        return getQuaternionFromAnotherGeodeticCRS(location,time,geodetic);
    }
}

// 同じdatumでgeographicなCRSを返す。
std::shared_ptr<GeographicCRS> GeodeticCRS::getGeographicCRS() const{
    if(isCartesian()){
        if(!isValid()){validate();}
        if(_geog.expired()){
            nl::json ic=instanceConfig;
            ic["ecef"]=non_const_this();
            auto shared=createEntityByClassName<GeographicCRS>(isEpisodic(),"CoordinateReferenceSystem","GeographicCRS",modelConfig,ic);
            _geog=shared;
            return _geog.lock();
        }else{
            return _geog.lock();
        }
    }else{
        if(_geog.expired()){
            _geog=getECEF()->getGeographicCRS();
            return _geog.lock();
        }else{
            return _geog.lock();
        }
    }
}
// 同じdatumでgeocentricかつEarth-fixedなCRS(Cartesian ECEF)を返す。
std::shared_ptr<GeodeticCRS> GeodeticCRS::getECEF() const{
    if(isCartesian()){
        return non_const_this<GeodeticCRS>();
    }else{
        if(!isValid()){validate();}
        if(!_ecef){
            nl::json ic=instanceConfig;
            ic["spherical_ecef"]=non_const_this();
            ic["isSpherical"]=false;
            _ecef=createEntityByClassName<GeodeticCRS>(isEpisodic(),"CoordinateReferenceSystem","GeodeticCRS",modelConfig,ic);
            return _ecef;
        }else{
            return _ecef;
        }
    }
}
// 同じdatumでgeocentricかつEarth-fixedなCRS(Spherical ECEF: geocentric lat-lon-radius)を返す。
std::shared_ptr<GeodeticCRS> GeodeticCRS::getSphericalECEF() const{
    if(isCartesian()){
        if(!isValid()){validate();}
        if(_spherical_ecef.expired()){
            nl::json ic=instanceConfig;
            ic["ecef"]=non_const_this();
            ic["isSpherical"]=true;
            auto shared=createEntityByClassName<GeographicCRS>(isEpisodic(),"CoordinateReferenceSystem","GeodeticCRS",modelConfig,ic);
            _spherical_ecef=shared;
            return _spherical_ecef.lock();
        }else{
            return _spherical_ecef.lock();
        }
    }else{
        return non_const_this<GeodeticCRS>();
    }
}
// 同じdatumでgeocentricかつinertialなCRS(ECI)を返す。
std::shared_ptr<EarthCenteredInetialCRS> GeodeticCRS::getECI() const{
    if(isCartesian()){
        if(_eci.expired()){
            throw std::runtime_error("This CRS does not have information about the corresponding ECI.");
        }else{
            return _eci.lock();
        }
    }else{
        if(_eci.expired()){
            _eci=getECEF()->getECI();
            return _eci.lock();
        }else{
            return _eci.lock();
        }
    }
}
// 同じdatumでgeographicなCRSとの間で座標変換する。
Coordinate GeodeticCRS::transformToGeographicCRS(const Coordinate& value,const Coordinate& location) const{
    if(location.getType()!=CoordinateType::POSITION_ABS){
        throw std::runtime_error("Given value is not a 'absolute location' coordinate.");
    }
    return transformToGeographicCRS(
        value(non_const_this()),
        location(non_const_this()),
        value.getTime(),
        value.getType()
    );
}
Coordinate GeodeticCRS::transformToGeographicCRS(const Coordinate& value) const{
    Coordinate valueInSelf=value.transformTo(non_const_this());
    return transformToGeographicCRS(
        valueInSelf(),
        valueInSelf.getLocation(),
        valueInSelf.getTime(),
        valueInSelf.getType()
    );
}
Coordinate GeodeticCRS::transformFromGeographicCRS(const Coordinate& value,const Coordinate& location) const{
    if(location.getType()!=CoordinateType::POSITION_ABS){
        throw std::runtime_error("Given value is not a 'absolute location' coordinate.");
    }
    return transformFromGeographicCRS(
        value(getGeographicCRS()),
        location(getGeographicCRS()),
        value.getTime(),
        value.getType()
    );
}
Coordinate GeodeticCRS::transformFromGeographicCRS(const Coordinate& value) const{
    Coordinate valueInGeog=value.transformTo(getGeographicCRS());
    return transformFromGeographicCRS(
        valueInGeog(),
        valueInGeog.getLocation(),
        valueInGeog.getTime(),
        valueInGeog.getType()
    );
}
Coordinate GeodeticCRS::transformToGeographicCRS(const Eigen::Vector3d& value_, const Eigen::Vector3d& location_, const Time& time, const CoordinateType& coordinateType) const{
    auto value=toCartesian(value_);
    auto location=toCartesian(location_);
    return Coordinate(
        transformECEFCoordinateToGeographicCRS(value,location,coordinateType),
        transformECEFCoordinateToGeographicCRS(location,location,CoordinateType::POSITION_ABS),
        getGeographicCRS(),
        time,
        coordinateType
    );
}
Coordinate GeodeticCRS::transformFromGeographicCRS(const Eigen::Vector3d& value, const Eigen::Vector3d& location, const Time& time, const CoordinateType& coordinateType) const{
    return Coordinate(
        fromCartesian(transformGeographicCoordinateToECEF(value,location,coordinateType)),
        fromCartesian(transformGeographicCoordinateToECEF(location,location,CoordinateType::POSITION_ABS)),
        non_const_this(),
        time,
        coordinateType
    );
}
Coordinate GeodeticCRS::transformToGeographicCRS(const Eigen::Vector3d& value, const Time& time, const CoordinateType& coordinateType) const{
    return transformToGeographicCRS(value,Eigen::Vector3d::Zero(),time,coordinateType);
}
Coordinate GeodeticCRS::transformFromGeographicCRS(const Eigen::Vector3d& value, const Time& time, const CoordinateType& coordinateType) const{
    return transformFromGeographicCRS(value,Eigen::Vector3d::Zero(),time,coordinateType);
}
// 同じdatumのECEFとの間で座標変換する。
Coordinate GeodeticCRS::transformToECEF(const Coordinate& value,const Coordinate& location) const{
    if(location.getType()!=CoordinateType::POSITION_ABS){
        throw std::runtime_error("Given value is not a 'absolute location' coordinate.");
    }
    return transformToECEF(
        value(non_const_this()),
        location(non_const_this()),
        value.getTime(),
        value.getType()
    );
}
Coordinate GeodeticCRS::transformToECEF(const Coordinate& value) const{
    Coordinate valueInSelf=value.transformTo(non_const_this());
    return transformToECEF(
        valueInSelf(),
        valueInSelf.getLocation(),
        valueInSelf.getTime(),
        valueInSelf.getType()
    );
}
Coordinate GeodeticCRS::transformFromECEF(const Coordinate& value,const Coordinate& location) const{
    if(location.getType()!=CoordinateType::POSITION_ABS){
        throw std::runtime_error("Given value is not a 'absolute location' coordinate.");
    }
    return transformFromECEF(
        value(getECEF()),
        location(getECEF()),
        value.getTime(),
        value.getType()
    );
}
Coordinate GeodeticCRS::transformFromECEF(const Coordinate& value) const{
    Coordinate valueInECEF=value.transformTo(getECEF());
    return transformFromECEF(
        valueInECEF(),
        valueInECEF.getLocation(),
        valueInECEF.getTime(),
        valueInECEF.getType()
    );
}
Coordinate GeodeticCRS::transformToECEF(const Eigen::Vector3d& value, const Eigen::Vector3d& location, const Time& time, const CoordinateType& coordinateType) const{
    if(isCartesian()){
        return std::move(Coordinate(
            value,
            location,
            non_const_this(),
            time,
            coordinateType
        ));
    }else{
        return std::move(Coordinate(
            toCartesian(value),
            toCartesian(location),
            getECEF(),
            time,
            coordinateType
        ));
    }
}
Coordinate GeodeticCRS::transformFromECEF(const Eigen::Vector3d& value, const Eigen::Vector3d& location, const Time& time, const CoordinateType& coordinateType) const{
    if(isCartesian()){
        return std::move(Coordinate(
            value,
            location,
            non_const_this(),
            time,
            coordinateType
        ));
    }else{
        return std::move(Coordinate(
            fromCartesian(value),
            fromCartesian(location),
            non_const_this(),
            time,
            coordinateType
        ));
    }
}
Coordinate GeodeticCRS::transformToECEF(const Eigen::Vector3d& value, const Time& time, const CoordinateType& coordinateType) const{
    return transformToECEF(value,Eigen::Vector3d::Zero(),time,coordinateType);
}
Coordinate GeodeticCRS::transformFromECEF(const Eigen::Vector3d& value, const Time& time, const CoordinateType& coordinateType) const{
    return transformFromECEF(value,Eigen::Vector3d::Zero(),time,coordinateType);
}

// 同じdatumのSpherical ECEFとの間で座標変換する。
Coordinate GeodeticCRS::transformToSphericalECEF(const Coordinate& value,const Coordinate& location) const{
    if(location.getType()!=CoordinateType::POSITION_ABS){
        throw std::runtime_error("Given value is not a 'absolute location' coordinate.");
    }
    return transformToSphericalECEF(
        value(non_const_this()),
        location(non_const_this()),
        value.getTime(),
        value.getType()
    );
}
Coordinate GeodeticCRS::transformToSphericalECEF(const Coordinate& value) const{
    Coordinate valueInSelf=value.transformTo(non_const_this());
    return transformToSphericalECEF(
        valueInSelf(),
        valueInSelf.getLocation(),
        valueInSelf.getTime(),
        valueInSelf.getType()
    );
}
Coordinate GeodeticCRS::transformFromSphericalECEF(const Coordinate& value,const Coordinate& location) const{
    if(location.getType()!=CoordinateType::POSITION_ABS){
        throw std::runtime_error("Given value is not a 'absolute location' coordinate.");
    }
    return transformFromSphericalECEF(
        value(getSphericalECEF()),
        location(getSphericalECEF()),
        value.getTime(),
        value.getType()
    );
}
Coordinate GeodeticCRS::transformFromSphericalECEF(const Coordinate& value) const{
    Coordinate valueInSphericalECEF=value.transformTo(getSphericalECEF());
    return transformFromSphericalECEF(
        valueInSphericalECEF(),
        valueInSphericalECEF.getLocation(),
        valueInSphericalECEF.getTime(),
        valueInSphericalECEF.getType()
    );
}
Coordinate GeodeticCRS::transformToSphericalECEF(const Eigen::Vector3d& value, const Eigen::Vector3d& location, const Time& time, const CoordinateType& coordinateType) const{
    if(isSpherical()){
        return std::move(Coordinate(
            value,
            location,
            non_const_this(),
            time,
            coordinateType
        ));
    }else{
        return std::move(Coordinate(
            toSpherical(value),
            toSpherical(location),
            getSphericalECEF(),
            time,
            coordinateType
        ));
    }
}
Coordinate GeodeticCRS::transformFromSphericalECEF(const Eigen::Vector3d& value, const Eigen::Vector3d& location, const Time& time, const CoordinateType& coordinateType) const{
    if(isSpherical()){
        return std::move(Coordinate(
            value,
            location,
            non_const_this(),
            time,
            coordinateType
        ));
    }else{
        return std::move(Coordinate(
            fromSpherical(value),
            fromSpherical(location),
            non_const_this(),
            time,
            coordinateType
        ));
    }
}
Coordinate GeodeticCRS::transformToSphericalECEF(const Eigen::Vector3d& value, const Time& time, const CoordinateType& coordinateType) const{
    return transformToSphericalECEF(value,Eigen::Vector3d::Zero(),time,coordinateType);
}
Coordinate GeodeticCRS::transformFromSphericalECEF(const Eigen::Vector3d& value, const Time& time, const CoordinateType& coordinateType) const{
    return transformFromSphericalECEF(value,Eigen::Vector3d::Zero(),time,coordinateType);
}

// 同じdatumのECIとの間で座標変換する。
Coordinate GeodeticCRS::transformToECI(const Coordinate& value,const Coordinate& location) const{
    if(location.getType()!=CoordinateType::POSITION_ABS){
        throw std::runtime_error("Given value is not a 'absolute location' coordinate.");
    }
    return transformToECI(
        value(non_const_this()),
        location(non_const_this()),
        value.getTime(),
        value.getType()
    );
}
Coordinate GeodeticCRS::transformToECI(const Coordinate& value) const{
    Coordinate valueInSelf=value.transformTo(non_const_this());
    return transformToECI(
        valueInSelf(),
        valueInSelf.getLocation(),
        valueInSelf.getTime(),
        valueInSelf.getType()
    );
}
Coordinate GeodeticCRS::transformFromECI(const Coordinate& value,const Coordinate& location) const{
    if(location.getType()!=CoordinateType::POSITION_ABS){
        throw std::runtime_error("Given value is not a 'absolute location' coordinate.");
    }
    return transformFromECI(
        value(getECI()),
        location(getECI()),
        value.getTime(),
        value.getType()
    );
}
Coordinate GeodeticCRS::transformFromECI(const Coordinate& value) const{
    Coordinate valueInECI=value.transformTo(getECI());
    return transformFromECI(
        valueInECI(),
        valueInECI.getLocation(),
        valueInECI.getTime(),
        valueInECI.getType()
    );
}
Coordinate GeodeticCRS::transformToECI(const Eigen::Vector3d& value, const Eigen::Vector3d& location, const Time& time, const CoordinateType& coordinateType) const{
    return getECI()->transformFromECEF(toCartesian(value),toCartesian(location),time,coordinateType);
}
Coordinate GeodeticCRS::transformFromECI(const Eigen::Vector3d& value, const Eigen::Vector3d& location, const Time& time, const CoordinateType& coordinateType) const{
    if(isCartesian()){
        return getECI()->transformToECEF(value,location,time,coordinateType);
    }else{
        return transformFromECEF(getECI()->transformToECEF(value,location,time,coordinateType));
    }
}
Coordinate GeodeticCRS::transformToECI(const Eigen::Vector3d& value, const Time& time, const CoordinateType& coordinateType) const{
    return transformToECI(value,Eigen::Vector3d::Zero(),time,coordinateType);
}
Coordinate GeodeticCRS::transformFromECI(const Eigen::Vector3d& value, const Time& time, const CoordinateType& coordinateType) const{
    return transformFromECI(value,Eigen::Vector3d::Zero(),time,coordinateType);
}

// 同じdatumでgeographic座標をECEF座標に変換する。
Eigen::Vector3d GeodeticCRS::transformGeographicCoordinateToECEF(const Eigen::Vector3d& value, const Eigen::Vector3d& location, const CoordinateType& coordinateType) const{
    if(coordinateType==CoordinateType::POSITION_ABS){
        // 絶対位置はEPSG:9602で変換する。
        return transformGeographicCoordinateToECEF(value,CoordinateType::POSITION_ABS);
    }else if(coordinateType==CoordinateType::POSITION_REL){
        // 相対位置の変換は始点と終点の位置をそれぞれ変換して差をとる。
        return (
            transformGeographicCoordinateToECEF(location+value,CoordinateType::POSITION_ABS)-
            transformGeographicCoordinateToECEF(location,CoordinateType::POSITION_ABS)
        );
    }else{
        // 位置以外は局所的な座標軸の向きと縮尺を考慮してヤコビアンにより変換する。
        // geocentric coordinate (X, Y, Z) in [m]
        // geographic coordinate (φ, λ, h) latitude[deg],longitude[deg],elliptic altitude[m]

        double lat=deg2rad(location(0));
        double lon=deg2rad(location(1));
        double alt=location(2);
        double f = 1.0/inverseFlattening();
        double e2 = f * (2 - f);
        double e2sin2lat=e2*pow(sin(lat),2);
        double nu=semiMajorAxis()/sqrt(1-e2sin2lat);

        double coeff = (nu*(1-e2)/(1-e2sin2lat)+alt);
        double dX_dphi = deg2rad(-coeff*sin(lat)*cos(lon));// [m/rad]→[m/deg]に換算しておく
        double dY_dphi = deg2rad(-coeff*sin(lat)*sin(lon));// [m/rad]→[m/deg]に換算しておく
        double dZ_dphi = deg2rad(coeff*cos(lat));// [m/rad]→[m/deg]に換算しておく

        double dX_dlam = deg2rad(-(nu+alt)*cos(lat)*sin(lon));// [m/rad]→[m/deg]に換算しておく
        double dY_dlam = deg2rad((nu+alt)*cos(lat)*cos(lon));// [m/rad]→[m/deg]に換算しておく

        Eigen::Matrix3d Rcg({
            {dX_dphi, dX_dlam, cos(lat)*cos(lon)},
            {dY_dphi, dY_dlam, cos(lat)*sin(lon)},
            {dZ_dphi,       0, sin(lat)}
        });
        if(coordinateType==CoordinateType::DIRECTION){
            return (Rcg*value).normalized();
        }else{
            return Rcg*value;
        }
    }
}
Eigen::Vector3d GeodeticCRS::transformGeographicCoordinateToECEF(const Eigen::Vector3d& value, const CoordinateType& coordinateType) const{
    if(coordinateType!=CoordinateType::POSITION_ABS){
        //絶対位置以外は観測点の指定を強制する。
        throw std::runtime_error("Geographic/ECEF conversion requires location of reference point, unless coordinateType==POSITION_ABS.");
    }
    // lat(rad),lon(rad),alt→XYZ
    // EPSG:9602
    double lat = deg2rad(value(0));
    double lon = deg2rad(value(1));
    double alt = value(2);
    double f = 1.0/_inverseFlattening;
    double e2 = f * (2 - f);
    double nu = _semiMajorAxis / sqrt(1.0 - e2 * pow(sin(lat), 2));
    return Eigen::Vector3d(
        (nu + alt) * cos(lat) * cos(lon),
        (nu + alt) * cos(lat) * sin(lon),
        ((1 - e2) * nu + alt) * sin(lat)
    );
}
// 同じdatumのECEF座標をgeographic座標に変換する。
Eigen::Vector3d GeodeticCRS::transformECEFCoordinateToGeographicCRS(const Eigen::Vector3d& value, const Eigen::Vector3d& location, const CoordinateType& coordinateType) const{
    if(coordinateType==CoordinateType::POSITION_ABS){
        // 絶対位置はEPSG:9602で変換する。
        return transformECEFCoordinateToGeographicCRS(value,CoordinateType::POSITION_ABS);

    }else if(coordinateType==CoordinateType::POSITION_REL){
        // 相対位置の変換は始点と終点の位置をそれぞれ変換して差をとる。
        return (
            transformECEFCoordinateToGeographicCRS(location+value,CoordinateType::POSITION_ABS)-
            transformECEFCoordinateToGeographicCRS(location,CoordinateType::POSITION_ABS)
        );
    }else{
        // 位置以外は局所的な座標軸の向きと縮尺を考慮してヤコビアンにより変換する。
        // geocentric coordinate (X, Y, Z) in [m]
        // geographic coordinate (φ, λ, h) latitude[deg],longitude[deg],elliptic altitude[m]
        Eigen::Vector3d lla=transformECEFCoordinateToGeographicCRS(location,CoordinateType::POSITION_ABS);
        double lat=deg2rad(lla(0));
        double lon=deg2rad(lla(1));
        double alt=lla(2);
        double f = 1.0/inverseFlattening();
        double e2 = f * (2 - f);
        double e2sin2lat=e2*pow(sin(lat),2);
        double nu=semiMajorAxis()/sqrt(1-e2sin2lat);

        double coeff = (nu*(1-e2)/(1-e2sin2lat)+alt);
        double dX_dphi = deg2rad(-coeff*sin(lat)*cos(lon));// [m/rad]→[m/deg]に換算しておく
        double dY_dphi = deg2rad(-coeff*sin(lat)*sin(lon));// [m/rad]→[m/deg]に換算しておく
        double dZ_dphi = deg2rad(coeff*cos(lat));// [m/rad]→[m/deg]に換算しておく

        double dX_dlam = deg2rad(-(nu+alt)*cos(lat)*sin(lon));// [m/rad]→[m/deg]に換算しておく
        double dY_dlam = deg2rad((nu+alt)*cos(lat)*cos(lon));// [m/rad]→[m/deg]に換算しておく

        Eigen::Matrix3d Rcg({
            {dX_dphi, dX_dlam, cos(lat)*cos(lon)},
            {dY_dphi, dY_dlam, cos(lat)*sin(lon)},
            {dZ_dphi,       0, sin(lat)}
        });
        if(coordinateType==CoordinateType::DIRECTION){
            return (Rcg.inverse()*value).normalized();
        }else{
            return Rcg.inverse()*value;
        }
    }
}
Eigen::Vector3d GeodeticCRS::transformECEFCoordinateToGeographicCRS(const Eigen::Vector3d& value, const CoordinateType& coordinateType) const{
    if(coordinateType!=CoordinateType::POSITION_ABS){
        //絶対位置以外は観測点の指定を強制する。
        throw std::runtime_error("Geographic/ECEF conversion requires location of reference point, unless coordinateType==POSITION_ABS.");
    }
    // XYZ→lat(rad),lon(rad),alt
    // EPSG:9602
    double X = value(0);
    double Y = value(1);
    double Z = value(2);
    double f = 1.0/_inverseFlattening;
    double e2 = f * (2 - f);
    double eps = e2 / (1 - e2);
    double b = _semiMajorAxis * (1 - f);
    double p = sqrt(X * X + Y * Y);
    double q = atan2(Z*_semiMajorAxis, p*b);
    double lat = atan2(Z+eps*b*pow(sin(q),3), p-e2*_semiMajorAxis*pow(cos(q),3));
    double lon = atan2(Y,X);
    double nu = _semiMajorAxis / sqrt(1.0 - e2 * pow(sin(lat), 2));
    return Eigen::Vector3d(
        rad2deg(lat),
        rad2deg(lon),
        p/cos(lat)-nu
    );
}

// 異なるdatumのGeodeticCRSに座標変換する。
bool GeodeticCRS::isTransformableToAnotherGeodeticCRS(const std::shared_ptr<GeodeticCRS>& other) const{
    // このクラスでは自分自身と、対になるCRSのみ。
    return bool(other) && (
        this==other.get() ||
        (!_geog.expired() && _geog.lock()==other) ||
        (bool(_ecef) && _ecef==other) ||
        (!_spherical_ecef.expired() && _spherical_ecef.lock()==other) ||
        (!_eci.expired() && _eci.lock()==other)
    );
}
bool GeodeticCRS::isTransformableFromAnotherGeodeticCRS(const std::shared_ptr<GeodeticCRS>& other) const{
    // このクラスでは自分自身と、対になるCRSのみ。
    return bool(other) && (
        this==other.get() ||
        (!_geog.expired() && _geog.lock()==other) ||
        (bool(_ecef) && _ecef==other) ||
        (!_spherical_ecef.expired() && _spherical_ecef.lock()==other) ||
        (!_eci.expired() && _eci.lock()==other)
    );
}
// 異なるdatumのGeodeticCRSに座標変換する。
Coordinate GeodeticCRS::transformToAnotherGeodeticCRS(const Eigen::Vector3d& value, const Eigen::Vector3d& location, const Time& time, const std::shared_ptr<GeodeticCRS>& dstCRS, const CoordinateType& coordinateType) const{
    if(this==dstCRS.get()){
        return std::move(Coordinate(
            value,
            location,
            dstCRS,
            time,
            coordinateType
        ));
    }else if(!_geog.expired() && _geog.lock()==std::dynamic_pointer_cast<GeographicCRS>(dstCRS)){
        return transformToGeographicCRS(value,location,time,coordinateType);
    }else if(bool(_ecef) && _ecef==dstCRS){
        return transformToECEF(value,location,time,coordinateType);
    }else if(!_spherical_ecef.expired() && _spherical_ecef.lock()==dstCRS){
        return transformToSphericalECEF(value,location,time,coordinateType);
    }else if(!_eci.expired() && _eci.lock()==std::dynamic_pointer_cast<EarthCenteredInetialCRS>(dstCRS)){
        return transformToECI(value,location,time,coordinateType);
    }
    throw std::runtime_error("GeodeticCRS class does not provide transformation to another datum. Use subclasses which implement such transformations.");
}
Coordinate GeodeticCRS::transformFromAnotherGeodeticCRS(const Eigen::Vector3d& value, const Eigen::Vector3d& location, const Time& time, const std::shared_ptr<GeodeticCRS>& srcCRS, const CoordinateType& coordinateType) const{
    if(this==srcCRS.get()){
        return std::move(Coordinate(
            value,
            location,
            non_const_this(),
            time,
            coordinateType
        ));
    }else if(!_geog.expired() && _geog.lock()==std::dynamic_pointer_cast<GeographicCRS>(srcCRS)){
        return transformFromGeographicCRS(value,location,time,coordinateType);
    }else if(bool(_ecef) && _ecef==srcCRS){
        return transformFromECEF(value,location,time,coordinateType);
    }else if(!_spherical_ecef.expired() && _spherical_ecef.lock()==srcCRS){
        return transformFromSphericalECEF(value,location,time,coordinateType);
    }else if(!_eci.expired() && _eci.lock()==std::dynamic_pointer_cast<EarthCenteredInetialCRS>(srcCRS)){
        return transformFromECI(value,location,time,coordinateType);
    }
    throw std::runtime_error("GeodeticCRS class does not provide transformation from another datum. Use subclasses which implement such transformations.");
}
Coordinate GeodeticCRS::transformToAnotherGeodeticCRS(const Eigen::Vector3d& value, const Time& time, const std::shared_ptr<GeodeticCRS>& dstCRS, const CoordinateType& coordinateType) const{
    return transformToAnotherGeodeticCRS(value,Eigen::Vector3d::Zero(),time,dstCRS,coordinateType);
}
Coordinate GeodeticCRS::transformFromAnotherGeodeticCRS(const Eigen::Vector3d& value, const Time& time, const std::shared_ptr<GeodeticCRS>& srcCRS, const CoordinateType& coordinateType) const{
    return transformFromAnotherGeodeticCRS(value,Eigen::Vector3d::Zero(),time,srcCRS,coordinateType);
}
Quaternion GeodeticCRS::getQuaternionToAnotherGeodeticCRS(const Coordinate& location, const std::shared_ptr<GeodeticCRS>& dstCRS) const{
    return getQuaternionToAnotherGeodeticCRS(location(non_const_this()),location.getTime(),dstCRS);
}
Quaternion GeodeticCRS::getQuaternionFromAnotherGeodeticCRS(const Coordinate& location) const{
    if(auto geod=std::dynamic_pointer_cast<GeodeticCRS>(location.getCRS())){
        return getQuaternionToAnotherGeodeticCRS(location(),location.getTime(),geod);
    }else{
        throw std::runtime_error("The CRS of the given location is not GeodeticCRS.");
    }
}
Quaternion GeodeticCRS::getQuaternionToAnotherGeodeticCRS(const Eigen::Vector3d& location, const Time& time, const std::shared_ptr<GeodeticCRS>& dstCRS) const{
    if(!isValid()){validate();}
    if(this==dstCRS.get()){
        return Quaternion(1,0,0,0);
    }else if(!_geog.expired() && _geog.lock()==std::dynamic_pointer_cast<GeographicCRS>(dstCRS)){
        throw std::runtime_error("Quaternion to/from a geographic CRS cannot be calculated.");
    }else if(!_spherical_ecef.expired() && _spherical_ecef.lock()==dstCRS){
        return Quaternion(1,0,0,0);
    }else if(auto eci=std::dynamic_pointer_cast<EarthCenteredInetialCRS>(dstCRS)){
        if(this==eci->getECEF().get()){
            return eci->getQuaternionFromECEF(location,time);
        }else{
            auto qToAnotherECEFFromSelf=getQuaternionToAnotherGeodeticCRS(location,time,eci->getECEF());
            auto locationInAnotherECEF=transformToAnotherGeodeticCRS(location,time,eci->getECEF(),CoordinateType::POSITION_ABS)();
            auto qToDstFromAnotherECEF=eci->getQuaternionFromECEF(locationInAnotherECEF,time);
            return qToDstFromAnotherECEF*qToAnotherECEFFromSelf;
        }
    }
    throw std::runtime_error("GeodeticCRS class does not provide transformation from another datum. Use subclasses which implement such transformations.");
}
Quaternion GeodeticCRS::getQuaternionFromAnotherGeodeticCRS(const Eigen::Vector3d& location, const Time& time, const std::shared_ptr<GeodeticCRS>& srcCRS) const{
    if(!isValid()){validate();}
    if(this==srcCRS.get()){
        return Quaternion(1,0,0,0);
    }else if(!_geog.expired() && _geog.lock()==std::dynamic_pointer_cast<GeographicCRS>(srcCRS)){
        throw std::runtime_error("Quaternion to/from a geographic CRS cannot be calculated.");
    }else if(!_spherical_ecef.expired() && _spherical_ecef.lock()==srcCRS){
        return Quaternion(1,0,0,0);
    }else if(auto eci=std::dynamic_pointer_cast<EarthCenteredInetialCRS>(srcCRS)){
        if(this==eci->getECEF().get()){
            return eci->getQuaternionToECEF(location,time);
        }else{
            auto locationInAnotherECEF=eci->transformECICoordinateToECEF(location,time,CoordinateType::POSITION_ABS);
            auto qToSelfFromAnotherECEF=getQuaternionFromAnotherGeodeticCRS(locationInAnotherECEF,time,eci->getECEF());
            auto qToAnotherECEFFromSrc=eci->getQuaternionToECEF(location,time);
            return qToSelfFromAnotherECEF*qToAnotherECEFFromSrc;
        }
    }
    throw std::runtime_error("GeodeticCRS class does not provide transformation from another datum. Use subclasses which implement such transformations.");
}
const double& GeodeticCRS::semiMajorAxis() const{
    if(!isValid()){validate();}
    return _semiMajorAxis;
}
const double& GeodeticCRS::inverseFlattening() const{
    if(!isValid()){validate();}
    return _inverseFlattening;
}
Quaternion GeodeticCRS::getEquivalentQuaternionToTopocentricCRS(const Eigen::Vector3d& origin, const Time& time, const std::string& axisOrder_) const{
    //CRSとして生成せずにクォータニオンとして得る。
    std::string axisOrder=axisOrder_;
    std::transform(axisOrder.begin(),axisOrder.end(),axisOrder.begin(),
        [](unsigned char c){ return std::toupper(c);}
    );
    // EPSG:9836
    auto ellipsoidalOrigin = this->transformECEFCoordinateToGeographicCRS(toCartesian(origin),CoordinateType::POSITION_ABS);
    double lat_0=deg2rad(ellipsoidalOrigin(0));
    double lon_0=deg2rad(ellipsoidalOrigin(1));
    Eigen::Matrix3d Rt({
        {-sin(lon_0), -sin(lat_0)*cos(lon_0), cos(lat_0)*cos(lon_0)},
        { cos(lon_0), -sin(lat_0)*sin(lon_0), cos(lat_0)*sin(lon_0)},
        {          0,             cos(lat_0),            sin(lat_0)}
    });
    auto qENU=Quaternion::fromRotationMatrix(Rt); // [this <- ENU]
    if(checkTopocentricCartesianAxisOrder(axisOrder)){
        if(axisOrder=="ENU"){
            return qENU.conjugate();
        }else{
            auto ret=getAxisSwapQuaternion("ENU",axisOrder)*qENU.conjugate();
            auto up=ret.transformVector(Eigen::Vector3d(cos(lat_0)*cos(lon_0),cos(lat_0)*sin(lon_0),sin(lat_0)));
            auto east=ret.transformVector(Eigen::Vector3d(-sin(lon_0),cos(lon_0),0));
            auto north=ret.transformVector(Eigen::Vector3d(-sin(lat_0)*cos(lon_0),-sin(lat_0)*sin(lon_0),cos(lat_0)));
            return getAxisSwapQuaternion("ENU",axisOrder)*qENU.conjugate(); // [axisOrder <- ENU] * [ENU <- this]
        }
    }else{// if(checkBodyCartesianAxisOrder(axisOrder){
        throw std::runtime_error("Body-oriented TopocentricCRS cannot be created from GeodeticCRS.");
    }
}

void GeodeticCRS::setGeographicCRS(const std::shared_ptr<GeographicCRS>& geog_) const{
    _geog=geog_;
}
void GeodeticCRS::setGeographicCRS(const std::shared_ptr<const GeodeticCRS>& base, const std::shared_ptr<GeographicCRS>& geog_){
    base->setGeographicCRS(geog_);
}
void GeodeticCRS::setECEF(const std::shared_ptr<GeodeticCRS>& ecef_) const{
    _ecef=ecef_;
}
void GeodeticCRS::setECEF(const std::shared_ptr<const GeodeticCRS>& base, const std::shared_ptr<GeodeticCRS>& ecef_){
    base->setECEF(ecef_);
}
void GeodeticCRS::setSphericalECEF(const std::shared_ptr<GeodeticCRS>& spherical_ecef_) const{
    _spherical_ecef=spherical_ecef_;
}
void GeodeticCRS::setSphericalECEF(const std::shared_ptr<const GeodeticCRS>& base, const std::shared_ptr<GeodeticCRS>& spherical_ecef_){
    base->setSphericalECEF(spherical_ecef_);
}
void GeodeticCRS::setECI(const std::shared_ptr<EarthCenteredInetialCRS>& eci_) const{
    _eci=eci_;
}
void GeodeticCRS::setECI(const std::shared_ptr<const GeodeticCRS>& base, const std::shared_ptr<EarthCenteredInetialCRS>& eci_){
    base->setECI(eci_);
}
Eigen::Vector3d GeodeticCRS::cartesianToSpherical(const Eigen::Vector3d& v) const{
    // ECEF X,Y,Z -> (geocentric lat, geocentric lon, geocentric radius)
    double xy=sqrt(v(0)*v(0)+v(1)*v(1));
    if(xy==0){
        return Eigen::Vector3d(
            v(2)>0 ? M_PI_2 : -M_PI_2,
            0,
            abs(v(2))
        );
    }else{
        double lat=atan2(v(2),xy);
        return Eigen::Vector3d(
            lat,
            atan2(v(1),v(0)),
            sqrt(xy*xy+v(2)*v(2))
        );
    }
}
Eigen::Vector3d GeodeticCRS::sphericalToCartesian(const Eigen::Vector3d& v) const{
    // (geocentric lat, geocentric lon, geocentric radius) -> ECEF X,Y,Z
    return Eigen::Vector3d(
        v(2)*cos(v(1))*cos(v(0)),
        v(2)*sin(v(1))*cos(v(0)),
        v(2)*sin(v(0))
    );
}

GeographicCRS::GeographicCRS(const nl::json& modelConfig_,const nl::json& instanceConfig_)
:GeodeticCRS(modelConfig_,instanceConfig_){
    crsType=CRSType::GEOGRAPHIC;
    if(isDummy){return;}
}
//座標系の種類
bool GeographicCRS::isGeocentric() const{
    return false;
}
bool GeographicCRS::isGeographic() const{
    return true;
}
//Coordinate system axisの種類
bool GeographicCRS::isCartesian() const{
    return false;
}
bool GeographicCRS::isSpherical() const{
    return false;
}
bool GeographicCRS::isEllipsoidal() const{
    return true;
}

//「高度」の取得
double GeographicCRS::getHeight(const Eigen::Vector3d& location, const Time& time) const{
    //楕円体高度(幾何高度)を返す。ellipsoid (geometric) height
    //基本はlat-lon-altで3次元目が楕円体高度を表すため、派生クラスで変更しない限りそれを返せば良い。
    //派生クラスでジオイドモデルを導入する場合には適宜オーバーライドすること。
    if(!isValid()){validate();}
    return location(2);
}
double GeographicCRS::getGeoidHeight(const Eigen::Vector3d& location, const Time& time) const{
    //標高(ジオイド高度)を返す。geoid height (elevation)
    //このクラスでは楕円体表面とジオイド面は一致するものとして解釈する。
    //派生クラスでジオイドモデルを導入する場合には適宜オーバーライドすること。
    if(!isValid()){validate();}
    return location(2);
}
Quaternion GeographicCRS::getQuaternionTo(const Eigen::Vector3d& location, const Time& time, const std::shared_ptr<CoordinateReferenceSystem>& dstCRS) const{
    throw std::runtime_error("Quaternion to/from a geographic CRS cannot be calculated.");
}
Quaternion GeographicCRS::getQuaternionFrom(const Eigen::Vector3d& location, const Time& time, const std::shared_ptr<CoordinateReferenceSystem>& srcCRS) const{
    throw std::runtime_error("Quaternion to/from a geographic CRS cannot be calculated.");
}
// 同じdatumでgeographicなCRSを返す。
std::shared_ptr<GeographicCRS> GeographicCRS::getGeographicCRS() const{
    return non_const_this<GeographicCRS>();
}
// 同じdatumでgeocentricかつEarth-fixedなCRS(ECEF)を返す。
std::shared_ptr<GeodeticCRS> GeographicCRS::getECEF() const{
    if(!isValid()){validate();}
    if(!_ecef){
        nl::json ic=instanceConfig;
        ic["geog"]=non_const_this();
        ic["isSpherical"]=false;
        _ecef=createEntityByClassName<GeodeticCRS>(isEpisodic(),"CoordinateReferenceSystem","GeodeticCRS",modelConfig,ic);
        return _ecef;
    }else{
        return _ecef;
    }
}
// 同じdatumでgeocentricかつEarth-fixedなCRS(Spherical ECEF: geocentric lat-lon-radius)を返す。
std::shared_ptr<GeodeticCRS> GeographicCRS::getSphericalECEF() const{
    if(_spherical_ecef.expired()){
        _spherical_ecef=getECEF()->getSphericalECEF();
        return _spherical_ecef.lock();
    }else{
        return _spherical_ecef.lock();
    }
}
// 同じdatumでgeocentricかつinertialなCRS(ECI)を返す。
std::shared_ptr<EarthCenteredInetialCRS> GeographicCRS::getECI() const{
    if(_eci.expired()){
        _eci=getECEF()->getECI();
        return _eci.lock();
    }else{
        return _eci.lock();
    }
}
// 同じdatumでgeographicなCRSとの間で座標変換する。
Coordinate GeographicCRS::transformToGeographicCRS(const Eigen::Vector3d& value, const Eigen::Vector3d& location, const Time& time, const CoordinateType& coordinateType) const{
    return Coordinate(
        value,
        location,
        non_const_this(),
        time,
        coordinateType
    );
}
Coordinate GeographicCRS::transformFromGeographicCRS(const Eigen::Vector3d& value, const Eigen::Vector3d& location, const Time& time, const CoordinateType& coordinateType) const{
    return Coordinate(
        value,
        location,
        non_const_this(),
        time,
        coordinateType
    );
}
// 同じdatumのECEFとの間で座標変換する。
Coordinate GeographicCRS::transformToECEF(const Eigen::Vector3d& value, const Eigen::Vector3d& location, const Time& time, const CoordinateType& coordinateType) const{
    return Coordinate(
        transformGeographicCoordinateToECEF(value,location,coordinateType),
        transformGeographicCoordinateToECEF(location,location,CoordinateType::POSITION_ABS),
        getECEF(),
        time,
        coordinateType
    );
}
Coordinate GeographicCRS::transformFromECEF(const Eigen::Vector3d& value, const Eigen::Vector3d& location, const Time& time, const CoordinateType& coordinateType) const{
    return Coordinate(
        transformECEFCoordinateToGeographicCRS(value,location,coordinateType),
        transformECEFCoordinateToGeographicCRS(location,location,CoordinateType::POSITION_ABS),
        getGeographicCRS(),
        time,
        coordinateType
    );
}
// 同じdatumのSpherical ECEFとの間で座標変換する。
Coordinate GeographicCRS::transformToSphericalECEF(const Eigen::Vector3d& value, const Eigen::Vector3d& location, const Time& time, const CoordinateType& coordinateType) const{
    return Coordinate(
        toSpherical(transformGeographicCoordinateToECEF(value,location,coordinateType)),
        toSpherical(transformGeographicCoordinateToECEF(location,location,CoordinateType::POSITION_ABS)),
        getSphericalECEF(),
        time,
        coordinateType
    );
}
Coordinate GeographicCRS::transformFromSphericalECEF(const Eigen::Vector3d& value_, const Eigen::Vector3d& location_, const Time& time, const CoordinateType& coordinateType) const{
    auto value=fromSpherical(value_);
    auto location=fromSpherical(location_);
    return Coordinate(
        transformECEFCoordinateToGeographicCRS(value,location,coordinateType),
        transformECEFCoordinateToGeographicCRS(location,location,CoordinateType::POSITION_ABS),
        getGeographicCRS(),
        time,
        coordinateType
    );
}
// 同じdatumのECIとの間で座標変換する。
Coordinate GeographicCRS::transformToECI(const Eigen::Vector3d& value, const Eigen::Vector3d& location, const Time& time, const CoordinateType& coordinateType) const{
    return getECEF()->transformToECI(transformToECEF(value,location,time,coordinateType));
}
Coordinate GeographicCRS::transformFromECI(const Eigen::Vector3d& value, const Eigen::Vector3d& location, const Time& time, const CoordinateType& coordinateType) const{
    return transformFromECEF(getECEF()->transformFromECI(value,location,time,coordinateType));
}
Quaternion GeographicCRS::getQuaternionToAnotherGeodeticCRS(const Eigen::Vector3d& location, const Time& time, const std::shared_ptr<GeodeticCRS>& dstCRS) const{
    throw std::runtime_error("Quaternion to/from a geographic CRS cannot be calculated.");
}
Quaternion GeographicCRS::getQuaternionFromAnotherGeodeticCRS(const Eigen::Vector3d& location, const Time& time, const std::shared_ptr<GeodeticCRS>& srcCRS) const{
    throw std::runtime_error("Quaternion to/from a geographic CRS cannot be calculated.");
}
// このCRS上の点originを原点とするtopocentricなCRSを生成して返す。
std::shared_ptr<TopocentricCRS> GeographicCRS::createTopocentricCRS(const Eigen::Vector3d& origin, const Time& time, const std::string& axisOrder, bool onSurface, bool isEpisodic) const{
    nl::json mc=nl::json::object();
    nl::json ic={
        {"base",{
            {"entityIdentifier",getEntityID()},
        }},
        {"ellipsoidalOrigin",origin},
        {"time",time},
        {"axisOrder",axisOrder},
        {"onSurface",onSurface}
    };
    return createEntityByClassName<TopocentricCRS>(isEpisodic,"CoordinateReferenceSystem","TopocentricCRS",mc,ic);
}
Quaternion GeographicCRS::getEquivalentQuaternionToTopocentricCRS(const Eigen::Vector3d& origin, const Time& time, const std::string& axisOrder_) const{
    //CRSとして生成せずにクォータニオンとして得る。
    std::string axisOrder=axisOrder_;
    std::transform(axisOrder.begin(),axisOrder.end(),axisOrder.begin(),
        [](unsigned char c){ return std::toupper(c);}
    );
    // EPSG:9836
    auto ellipsoidalOrigin = origin;
    double lat_0=deg2rad(ellipsoidalOrigin(0));
    double lon_0=deg2rad(ellipsoidalOrigin(1));
    Eigen::Matrix3d Rt({
        {-sin(lon_0), -sin(lat_0)*cos(lon_0), cos(lat_0)*cos(lon_0)},
        { cos(lon_0), -sin(lat_0)*sin(lon_0), cos(lat_0)*sin(lon_0)},
        {          0,             cos(lat_0),            sin(lat_0)}
    });
    auto qENU=Quaternion::fromRotationMatrix(Rt); // [this <- ENU]
    if(checkTopocentricCartesianAxisOrder(axisOrder)){
        if(axisOrder=="ENU"){
            return qENU.conjugate();
        }else{
            return getAxisSwapQuaternion("ENU",axisOrder)*qENU.conjugate(); // [axisOrder <- ENU] * [ENU <- this]
        }
    }else{// if(checkBodyCartesianAxisOrder(axisOrder){
        throw std::runtime_error("Body-oriented TopocentricCRS cannot be created from GeographicCRS.");
    }
}
// このCRSをparentとして持つMotionStateに対応するAffineCRSを生成して返す。
std::shared_ptr<AffineCRS> GeographicCRS::createAffineCRS(const MotionState& motion, const std::string& axisOrder, bool isEpisodic) const{
    throw std::runtime_error("GeographicCRS cannot derive AffineCRS.");
}

EarthCenteredInetialCRS::EarthCenteredInetialCRS(const nl::json& modelConfig_,const nl::json& instanceConfig_)
:GeodeticCRS(modelConfig_,instanceConfig_){
    crsType=CRSType::ECI;
    if(isDummy){return;}
}
//座標系の種類
bool EarthCenteredInetialCRS::isEarthFixed() const{
    return false;
}
//「高度」の取得
double EarthCenteredInetialCRS::getHeight(const Eigen::Vector3d& location, const Time& time) const{
    //楕円体高度(幾何高度)を返す。ellipsoid (geometric) height
    //ECIの場合はECEFを経由してGeographicに変換してそちらから返す。
    if(!isValid()){validate();}
    return getECEF()->getHeight(transformECICoordinateToECEF(location,time,CoordinateType::POSITION_ABS),time);
}
double EarthCenteredInetialCRS::getGeoidHeight(const Eigen::Vector3d& location, const Time& time) const{
    //標高(ジオイド高度)を返す。geoid height (elevation)
    //ECIの場合はECEFを経由してGeographicに変換してそちらから返す。
    if(!isValid()){validate();}
    return getECEF()->getGeoidHeight(transformECICoordinateToECEF(location,time,CoordinateType::POSITION_ABS),time);
}
// 同じdatumでgeographicなCRSを返す。
std::shared_ptr<GeographicCRS> EarthCenteredInetialCRS::getGeographicCRS() const{
    return getECEF()->getGeographicCRS();
}
// 同じdatumでgeocentricかつEarth-fixedなCRS(Cartesian ECEF)を返す。
std::shared_ptr<GeodeticCRS> EarthCenteredInetialCRS::getECEF() const{
    if(!isValid()){validate();}
    return _ecef;
}
// 同じdatumでgeocentricかつEarth-fixedなCRS(Spherical ECEF: geocentric lat-lon-radius)を返す。
std::shared_ptr<GeodeticCRS> EarthCenteredInetialCRS::getSphericalECEF() const{
    return getECEF()->getSphericalECEF();
}
// 同じdatumでgeocentricかつinertialなCRS(ECI)を返す。
std::shared_ptr<EarthCenteredInetialCRS> EarthCenteredInetialCRS::getECI() const{
    return non_const_this<EarthCenteredInetialCRS>();
}
// 異なるdatumのGeodeticCRSに座標変換する。
bool EarthCenteredInetialCRS::isTransformableToAnotherGeodeticCRS(const std::shared_ptr<GeodeticCRS>& other) const{
    return getECEF()->isTransformableToAnotherGeodeticCRS(other);
}
bool EarthCenteredInetialCRS::isTransformableFromAnotherGeodeticCRS(const std::shared_ptr<GeodeticCRS>& other) const{
    return getECEF()->isTransformableFromAnotherGeodeticCRS(other);
}
// 同じdatumでgeographicなCRSとの間で座標変換する。
Coordinate EarthCenteredInetialCRS::transformToGeographicCRS(const Eigen::Vector3d& value, const Eigen::Vector3d& location, const Time& time, const CoordinateType& coordinateType) const{
    return getECEF()->transformToGeographicCRS(transformToECEF(value,location,time,coordinateType));
}
Coordinate EarthCenteredInetialCRS::transformFromGeographicCRS(const Eigen::Vector3d& value, const Eigen::Vector3d& location, const Time& time, const CoordinateType& coordinateType) const{
    return transformFromECEF(getECEF()->transformFromGeographicCRS(value,location,time,coordinateType));
}
// 同じdatumのECEFとの間で座標変換する。
Coordinate EarthCenteredInetialCRS::transformToECEF(const Eigen::Vector3d& value, const Eigen::Vector3d& location, const Time& time, const CoordinateType& coordinateType) const{
    return Coordinate(
        transformECICoordinateToECEF(value,location,time,coordinateType),
        transformECICoordinateToECEF(location,location,time,CoordinateType::POSITION_ABS),
        getECEF(),
        time,
        coordinateType
    );
}
Coordinate EarthCenteredInetialCRS::transformFromECEF(const Eigen::Vector3d& value, const Eigen::Vector3d& location, const Time& time, const CoordinateType& coordinateType) const{
    return Coordinate(
        transformECEFCoordinateToECI(value,location,time,coordinateType),
        transformECEFCoordinateToECI(location,location,time,CoordinateType::POSITION_ABS),
        getECI(),
        time,
        coordinateType
    );
}
// 同じdatumのSpherical ECEFとの間で座標変換する。
Coordinate EarthCenteredInetialCRS::transformToSphericalECEF(const Eigen::Vector3d& value, const Eigen::Vector3d& location, const Time& time, const CoordinateType& coordinateType) const{
    return Coordinate(
        toSpherical(transformECICoordinateToECEF(value,location,time,coordinateType)),
        toSpherical(transformECICoordinateToECEF(location,location,time,CoordinateType::POSITION_ABS)),
        getSphericalECEF(),
        time,
        coordinateType
    );
}
Coordinate EarthCenteredInetialCRS::transformFromSphericalECEF(const Eigen::Vector3d& value_, const Eigen::Vector3d& location_, const Time& time, const CoordinateType& coordinateType) const{
    auto value=fromSpherical(value_);
    auto location=fromSpherical(location_);
    return Coordinate(
        transformECEFCoordinateToECI(value,location,time,coordinateType),
        transformECEFCoordinateToECI(location,location,time,CoordinateType::POSITION_ABS),
        getECI(),
        time,
        coordinateType
    );
}
// 同じdatumのECIとの間で座標変換する。
Coordinate EarthCenteredInetialCRS::transformToECI(const Eigen::Vector3d& value, const Eigen::Vector3d& location, const Time& time, const CoordinateType& coordinateType) const{
    return std::move(Coordinate(
        value,
        location,
        non_const_this(),
        time,
        coordinateType
    ));
}
Coordinate EarthCenteredInetialCRS::transformFromECI(const Eigen::Vector3d& value, const Eigen::Vector3d& location, const Time& time, const CoordinateType& coordinateType) const{
    return std::move(Coordinate(
        value,
        location,
        non_const_this(),
        time,
        coordinateType
    ));
}

Quaternion EarthCenteredInetialCRS::getQuaternionToAnotherGeodeticCRS(const Eigen::Vector3d& location, const Time& time, const std::shared_ptr<GeodeticCRS>& dstCRS) const{
    if(!isValid()){validate();}
    if(this==dstCRS.get()){
        return Quaternion(1,0,0,0);
    }
    auto qToECEFFromECI=getQuaternionToECEF(location,time);
    auto locationInECEF=transformToECEF(location,location,time,CoordinateType::POSITION_ABS)();
    auto qToDstFromECEF=getECEF()->getQuaternionToAnotherGeodeticCRS(locationInECEF,time,dstCRS);
    return qToDstFromECEF*qToECEFFromECI;
}
Quaternion EarthCenteredInetialCRS::getQuaternionFromAnotherGeodeticCRS(const Eigen::Vector3d& location, const Time& time, const std::shared_ptr<GeodeticCRS>& srcCRS) const{
    if(!isValid()){validate();}
    if(this==srcCRS.get()){
        return Quaternion(1,0,0,0);
    }
    auto locationInECEF=getECEF()->transformFromAnotherGeodeticCRS(location,time,srcCRS,CoordinateType::POSITION_ABS)();
    auto qToECIFromECEF=getQuaternionFromECEF(locationInECEF,time);
    auto qToECEFFromSrc=getECEF()->getQuaternionFromAnotherGeodeticCRS(location,time,srcCRS);
    return qToECIFromECEF*qToECEFFromSrc;
}
Quaternion EarthCenteredInetialCRS::getQuaternionToECEF(const Coordinate& location) const{
    return getQuaternionToECEF(location(non_const_this()),location.getTime());
}
Quaternion EarthCenteredInetialCRS::getQuaternionToECEF(const Eigen::Vector3d& location, const Time& time) const{
    if(!isValid()){validate();}
    Eigen::Vector3d locationInECEF=transformToECEF(location,time,CoordinateType::POSITION_ABS)();
    return Quaternion::fromBasis(
        transformToECEF(Eigen::Vector3d(1,0,0)+location,time,CoordinateType::POSITION_ABS)()-locationInECEF,
        transformToECEF(Eigen::Vector3d(0,1,0)+location,time,CoordinateType::POSITION_ABS)()-locationInECEF,
        transformToECEF(Eigen::Vector3d(0,0,1)+location,time,CoordinateType::POSITION_ABS)()-locationInECEF
    );
}
Quaternion EarthCenteredInetialCRS::getQuaternionFromECEF(const Eigen::Vector3d& location, const Time& time) const{
    if(!isValid()){validate();}
    Eigen::Vector3d locationInSelf=transformFromECEF(location,time,CoordinateType::POSITION_ABS)();
    return Quaternion::fromBasis(
        transformFromECEF(Eigen::Vector3d(1,0,0)+location,time,CoordinateType::POSITION_ABS)()-locationInSelf,
        transformFromECEF(Eigen::Vector3d(0,1,0)+location,time,CoordinateType::POSITION_ABS)()-locationInSelf,
        transformFromECEF(Eigen::Vector3d(0,0,1)+location,time,CoordinateType::POSITION_ABS)()-locationInSelf
    );
}
Quaternion EarthCenteredInetialCRS::getEquivalentQuaternionToTopocentricCRS(const Eigen::Vector3d& origin, const Time& time, const std::string& axisOrder_) const{
    //CRSとして生成せずにクォータニオンとして得る。
    auto qToECEFFromSelf=getQuaternionToECEF(origin,time);
    auto originInECEF=transformToECEF(origin,time,CoordinateType::POSITION_ABS)();
    auto qToTopoFromECEF=getECEF()->getEquivalentQuaternionToTopocentricCRS(originInECEF,time,axisOrder_);
    return qToTopoFromECEF*qToECEFFromSelf;
}

void IdealSteadyRotationECI::initialize(){
    BaseType::initialize();
    //元期(ECEFとECIの座標軸が一致する時刻として)
    if(instanceConfig.contains("epoch")){
        epoch=instanceConfig.at("epoch");
    }else if(modelConfig.contains("epoch")){
        epoch=modelConfig.at("epoch");
    }else{
        throw std::runtime_error("IdealSteadyRotationEC requires 'epoch' in the config.");
    }
    
    //角速度ベクトル(ECEF座標)
    if(instanceConfig.contains("axis")){
        axis=instanceConfig.at("axis");
    }else if(modelConfig.contains("axis")){
        axis=modelConfig.at("axis");
    }else{
        axis=Eigen::Vector3d(0,0,1);
    }
    axis.normalize();
}
// 内部状態のシリアライゼーション
void IdealSteadyRotationECI::serializeInternalState(asrc::core::util::AvailableArchiveTypes & archive, bool full){
    BaseType::serializeInternalState(archive,full);

    if(asrc::core::util::isInputArchive(archive)){
        //元期(ECEFとECIの座標軸が一致する時刻として)
        if(instanceConfig.contains("epoch")){
            epoch=instanceConfig.at("epoch");
        }else if(modelConfig.contains("epoch")){
            epoch=modelConfig.at("epoch");
        }else{
            throw std::runtime_error("IdealSteadyRotationEC requires 'epoch' in the config.");
        }
        
        //角速度ベクトル(ECEF座標)
        if(instanceConfig.contains("axis")){
            axis=instanceConfig.at("axis");
        }else if(modelConfig.contains("axis")){
            axis=modelConfig.at("axis");
        }else{
            axis=Eigen::Vector3d(0,0,1);
        }
        axis.normalize();
    }
}
// 同じdatumでECI座標をECEF座標に変換する。(internal use)
Eigen::Vector3d IdealSteadyRotationECI::transformECICoordinateToECEF(const Eigen::Vector3d& value, const Eigen::Vector3d& location, const Time& time, const CoordinateType& coordinateType) const{
    double days_ut1=(time.toUT1()-epoch.origin.toUT1())/86400.0;
    days_ut1-=(int)days_ut1;
    double era=days_ut1*2*M_PI; //Earth Rotation Angle [rad]
    MotionState eciMotionInECEF(
        getECEF(),
        time,
        Eigen::Vector3d::Zero(),
        Eigen::Vector3d::Zero(),
        axis*2*M_PI/86400.0,
        Quaternion::fromAngle(axis,era)
    );
    if(coordinateType==CoordinateType::POSITION_ABS){
        return eciMotionInECEF.absBtoP(value);
    }else if(coordinateType==CoordinateType::POSITION_REL){
        return eciMotionInECEF.relBtoP(value);
    }else if(coordinateType==CoordinateType::DIRECTION){
        return eciMotionInECEF.dirBtoP(value);
    }else if(coordinateType==CoordinateType::VELOCITY){
        return eciMotionInECEF.velBtoP(value,location);
    }else if(coordinateType==CoordinateType::ANGULAR_VELOCITY){
        return eciMotionInECEF.omegaBtoP(value);
    }else{
        throw std::runtime_error("Invalide coordinate type.");
    }
}
Eigen::Vector3d IdealSteadyRotationECI::transformECICoordinateToECEF(const Eigen::Vector3d& value, const Time& time, const CoordinateType& coordinateType) const{
    return transformECICoordinateToECEF(value,Eigen::Vector3d::Zero(),time,coordinateType);
}
// 同じdatumでECEF座標をECI座標に変換する。(internal use)
Eigen::Vector3d IdealSteadyRotationECI::transformECEFCoordinateToECI(const Eigen::Vector3d& value, const Eigen::Vector3d& location, const Time& time, const CoordinateType& coordinateType) const{
    double days_ut1=(time.toUT1()-epoch.origin.toUT1())/86400.0;
    days_ut1-=(int)days_ut1;
    double era=days_ut1*2*M_PI; //Earth Rotation Angle [rad]
    MotionState eciMotionInECEF(
        getECEF(),
        time,
        Eigen::Vector3d::Zero(),
        Eigen::Vector3d::Zero(),
        axis*2*M_PI/86400.0,
        Quaternion::fromAngle(axis,era)
    );
    if(coordinateType==CoordinateType::POSITION_ABS){
        return eciMotionInECEF.absPtoB(value);
    }else if(coordinateType==CoordinateType::POSITION_REL){
        return eciMotionInECEF.relPtoB(value);
    }else if(coordinateType==CoordinateType::DIRECTION){
        return eciMotionInECEF.dirPtoB(value);
    }else if(coordinateType==CoordinateType::VELOCITY){
        return eciMotionInECEF.velPtoB(value,location);
    }else if(coordinateType==CoordinateType::ANGULAR_VELOCITY){
        return eciMotionInECEF.omegaPtoB(value);
    }else{
        throw std::runtime_error("Invalide coordinate type.");
    }
}
Eigen::Vector3d IdealSteadyRotationECI::transformECEFCoordinateToECI(const Eigen::Vector3d& value, const Time& time, const CoordinateType& coordinateType) const{
    return transformECEFCoordinateToECI(value,Eigen::Vector3d::Zero(),time,coordinateType);
}

Quaternion IdealSteadyRotationECI::getQuaternionToECEF(const Eigen::Vector3d& location, const Time& time) const{
    if(!isValid()){validate();}
    double days_ut1=(time.toUT1()-epoch.origin.toUT1())/86400.0;
    days_ut1-=(int)days_ut1;
    double era=days_ut1*2*M_PI; //Earth Rotation Angle [rad]
    return Quaternion::fromAngle(axis,era);
}
Quaternion IdealSteadyRotationECI::getQuaternionFromECEF(const Eigen::Vector3d& location, const Time& time) const{
    if(!isValid()){validate();}
    double days_ut1=(time.toUT1()-epoch.origin.toUT1())/86400.0;
    days_ut1-=(int)days_ut1;
    double era=days_ut1*2*M_PI; //Earth Rotation Angle [rad]
    return Quaternion::fromAngle(axis,era).conjugate();
}

void exportGeodeticCRS(py::module &m, const std::shared_ptr<asrc::core::FactoryHelper>& factoryHelper){
    using namespace pybind11::literals;

    expose_entity_subclass<GeodeticCRS>(m,"GeodeticCRS")
    DEF_FUNC(GeodeticCRS,getGeographicCRS)
    DEF_FUNC(GeodeticCRS,getECEF)
    DEF_FUNC(GeodeticCRS,getSphericalECEF)
    DEF_FUNC(GeodeticCRS,getECI)
    .def("transformToGeographicCRS",py::overload_cast<const Coordinate&,const Coordinate&>(&GeodeticCRS::transformToGeographicCRS,py::const_))
    .def("transformToGeographicCRS",py::overload_cast<const Coordinate&>(&GeodeticCRS::transformToGeographicCRS,py::const_))
    .def("transformToGeographicCRS",py::overload_cast<const Eigen::Vector3d&,const Eigen::Vector3d&,const Time&,const CoordinateType&>(&GeodeticCRS::transformToGeographicCRS,py::const_))
    .def("transformToGeographicCRS",py::overload_cast<const Eigen::Vector3d&,const Time&,const CoordinateType&>(&GeodeticCRS::transformToGeographicCRS,py::const_))
    .def("transformFromGeographicCRS",py::overload_cast<const Coordinate&,const Coordinate&>(&GeodeticCRS::transformFromGeographicCRS,py::const_))
    .def("transformFromGeographicCRS",py::overload_cast<const Coordinate&>(&GeodeticCRS::transformFromGeographicCRS,py::const_))
    .def("transformFromGeographicCRS",py::overload_cast<const Eigen::Vector3d&,const Eigen::Vector3d&,const Time&,const CoordinateType&>(&GeodeticCRS::transformFromGeographicCRS,py::const_))
    .def("transformFromGeographicCRS",py::overload_cast<const Eigen::Vector3d&,const Time&,const CoordinateType&>(&GeodeticCRS::transformFromGeographicCRS,py::const_))
    .def("transformToECEF",py::overload_cast<const Coordinate&,const Coordinate&>(&GeodeticCRS::transformToECEF,py::const_))
    .def("transformToECEF",py::overload_cast<const Coordinate&>(&GeodeticCRS::transformToECEF,py::const_))
    .def("transformToECEF",py::overload_cast<const Eigen::Vector3d&,const Eigen::Vector3d&,const Time&,const CoordinateType&>(&GeodeticCRS::transformToECEF,py::const_))
    .def("transformToECEF",py::overload_cast<const Eigen::Vector3d&,const Time&,const CoordinateType&>(&GeodeticCRS::transformToECEF,py::const_))
    .def("transformFromECEF",py::overload_cast<const Coordinate&,const Coordinate&>(&GeodeticCRS::transformFromECEF,py::const_))
    .def("transformFromECEF",py::overload_cast<const Coordinate&>(&GeodeticCRS::transformFromECEF,py::const_))
    .def("transformFromECEF",py::overload_cast<const Eigen::Vector3d&,const Eigen::Vector3d&,const Time&,const CoordinateType&>(&GeodeticCRS::transformFromECEF,py::const_))
    .def("transformFromECEF",py::overload_cast<const Eigen::Vector3d&,const Time&,const CoordinateType&>(&GeodeticCRS::transformFromECEF,py::const_))
    .def("transformToSphericalECEF",py::overload_cast<const Coordinate&,const Coordinate&>(&GeodeticCRS::transformToSphericalECEF,py::const_))
    .def("transformToSphericalECEF",py::overload_cast<const Coordinate&>(&GeodeticCRS::transformToSphericalECEF,py::const_))
    .def("transformToSphericalECEF",py::overload_cast<const Eigen::Vector3d&,const Eigen::Vector3d&,const Time&,const CoordinateType&>(&GeodeticCRS::transformToSphericalECEF,py::const_))
    .def("transformToSphericalECEF",py::overload_cast<const Eigen::Vector3d&,const Time&,const CoordinateType&>(&GeodeticCRS::transformToSphericalECEF,py::const_))
    .def("transformFromSphericalECEF",py::overload_cast<const Coordinate&,const Coordinate&>(&GeodeticCRS::transformFromSphericalECEF,py::const_))
    .def("transformFromSphericalECEF",py::overload_cast<const Coordinate&>(&GeodeticCRS::transformFromSphericalECEF,py::const_))
    .def("transformFromSphericalECEF",py::overload_cast<const Eigen::Vector3d&,const Eigen::Vector3d&,const Time&,const CoordinateType&>(&GeodeticCRS::transformFromSphericalECEF,py::const_))
    .def("transformFromSphericalECEF",py::overload_cast<const Eigen::Vector3d&,const Time&,const CoordinateType&>(&GeodeticCRS::transformFromSphericalECEF,py::const_))
    .def("transformToECI",py::overload_cast<const Coordinate&,const Coordinate&>(&GeodeticCRS::transformToECI,py::const_))
    .def("transformToECI",py::overload_cast<const Coordinate&>(&GeodeticCRS::transformToECI,py::const_))
    .def("transformToECI",py::overload_cast<const Eigen::Vector3d&,const Eigen::Vector3d&,const Time&,const CoordinateType&>(&GeodeticCRS::transformToECI,py::const_))
    .def("transformToECI",py::overload_cast<const Eigen::Vector3d&,const Time&,const CoordinateType&>(&GeodeticCRS::transformToECI,py::const_))
    .def("transformFromECI",py::overload_cast<const Coordinate&,const Coordinate&>(&GeodeticCRS::transformFromECI,py::const_))
    .def("transformFromECI",py::overload_cast<const Coordinate&>(&GeodeticCRS::transformFromECI,py::const_))
    .def("transformFromECI",py::overload_cast<const Eigen::Vector3d&,const Eigen::Vector3d&,const Time&,const CoordinateType&>(&GeodeticCRS::transformFromECI,py::const_))
    .def("transformFromECI",py::overload_cast<const Eigen::Vector3d&,const Time&,const CoordinateType&>(&GeodeticCRS::transformFromECI,py::const_))
    .def("transformGeographicCoordinateToECEF",py::overload_cast<const Eigen::Vector3d&,const Eigen::Vector3d&,const CoordinateType&>(&GeodeticCRS::transformGeographicCoordinateToECEF,py::const_))
    .def("transformGeographicCoordinateToECEF",py::overload_cast<const Eigen::Vector3d&,const CoordinateType&>(&GeodeticCRS::transformGeographicCoordinateToECEF,py::const_))
    .def("transformECEFCoordinateToGeographicCRS",py::overload_cast<const Eigen::Vector3d&,const Eigen::Vector3d&,const CoordinateType&>(&GeodeticCRS::transformECEFCoordinateToGeographicCRS,py::const_))
    .def("transformECEFCoordinateToGeographicCRS",py::overload_cast<const Eigen::Vector3d&,const CoordinateType&>(&GeodeticCRS::transformECEFCoordinateToGeographicCRS,py::const_))
    DEF_FUNC(GeodeticCRS,isTransformableToAnotherGeodeticCRS)
    DEF_FUNC(GeodeticCRS,isTransformableFromAnotherGeodeticCRS)
    .def("transformToAnotherGeodeticCRS",py::overload_cast<const Eigen::Vector3d&,const Eigen::Vector3d&,const Time&,const std::shared_ptr<GeodeticCRS>&,const CoordinateType&>(&GeodeticCRS::transformToAnotherGeodeticCRS,py::const_))
    .def("transformToAnotherGeodeticCRS",py::overload_cast<const Eigen::Vector3d&,const Time&,const std::shared_ptr<GeodeticCRS>&,const CoordinateType&>(&GeodeticCRS::transformToAnotherGeodeticCRS,py::const_))
    .def("transformFromAnotherGeodeticCRS",py::overload_cast<const Eigen::Vector3d&,const Eigen::Vector3d&,const Time&,const std::shared_ptr<GeodeticCRS>&,const CoordinateType&>(&GeodeticCRS::transformFromAnotherGeodeticCRS,py::const_))
    .def("transformFromAnotherGeodeticCRS",py::overload_cast<const Eigen::Vector3d&,const Time&,const std::shared_ptr<GeodeticCRS>&,const CoordinateType&>(&GeodeticCRS::transformFromAnotherGeodeticCRS,py::const_))
    .def("getQuaternionToAnotherGeodeticCRS",py::overload_cast<const Coordinate&,const std::shared_ptr<GeodeticCRS>&>(&GeodeticCRS::getQuaternionToAnotherGeodeticCRS,py::const_))
    .def("getQuaternionFromAnotherGeodeticCRS",py::overload_cast<const Coordinate&>(&GeodeticCRS::getQuaternionFromAnotherGeodeticCRS,py::const_))
    .def("getQuaternionToAnotherGeodeticCRS",py::overload_cast<const Eigen::Vector3d&,const Time&,const std::shared_ptr<GeodeticCRS>&>(&GeodeticCRS::getQuaternionToAnotherGeodeticCRS,py::const_))
    .def("getQuaternionFromAnotherGeodeticCRS",py::overload_cast<const Eigen::Vector3d&,const Time&,const std::shared_ptr<GeodeticCRS>&>(&GeodeticCRS::getQuaternionFromAnotherGeodeticCRS,py::const_))
    .def_property_readonly("semiMajorAxis",&GeodeticCRS::semiMajorAxis)
    .def_property_readonly("inverseFlattening",&GeodeticCRS::inverseFlattening)
    ;

    expose_entity_subclass<GeographicCRS>(m,"GeographicCRS")
    ;

    expose_entity_subclass<EarthCenteredInetialCRS>(m,"EarthCenteredInetialCRS")
    .def("transformECICoordinateToECEF",py::overload_cast<const Eigen::Vector3d&,const Eigen::Vector3d&,const Time&,const CoordinateType&>(&EarthCenteredInetialCRS::transformECICoordinateToECEF,py::const_))
    .def("transformECICoordinateToECEF",py::overload_cast<const Eigen::Vector3d&,const Time&,const CoordinateType&>(&EarthCenteredInetialCRS::transformECICoordinateToECEF,py::const_))
    .def("transformECEFCoordinateToECI",py::overload_cast<const Eigen::Vector3d&,const Eigen::Vector3d&,const Time&,const CoordinateType&>(&EarthCenteredInetialCRS::transformECEFCoordinateToECI,py::const_))
    .def("transformECEFCoordinateToECI",py::overload_cast<const Eigen::Vector3d&,const Time&,const CoordinateType&>(&EarthCenteredInetialCRS::transformECEFCoordinateToECI,py::const_))
    ;

    expose_entity_subclass<IdealSteadyRotationECI>(m,"IdealSteadyRotationECI")
    ;

    FACTORY_ADD_CLASS(CoordinateReferenceSystem,GeodeticCRS)
    FACTORY_ADD_CLASS(CoordinateReferenceSystem,GeographicCRS)
    FACTORY_ADD_CLASS(CoordinateReferenceSystem,IdealSteadyRotationECI)
}

ASRC_NAMESPACE_END(core)
ASRC_NAMESPACE_END(asrc)
